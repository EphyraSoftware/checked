//! Distribute public keys to be used for verification.

use crate::convert::try_extract_entry_to_app_type;
use crate::key_util::{check_mini_sign_proof, try_read_mini_sign_vf_key};
use crate::{LinkTypes, UnitEntryTypes};
use chrono::{DateTime, Utc};
use hdi::prelude::*;

pub const VERIFICATION_KEY_NAME_MIN_LENGTH: usize = 3;

/// Supported key types for verification keys.
#[derive(Serialize, Deserialize, Clone, PartialEq, Debug)]
pub enum VerificationKeyType {
    /// MiniSign verification key, using the Ed25519 algorithm. See the [minisign](https://jedisct1.github.io/minisign/) documentation for more information.
    MiniSignEd25519,
}

#[hdk_entry_helper]
#[derive(Clone, PartialEq)]
pub struct VerificationKeyDist {
    /// Text representation of the verification key. This will vary by key type.
    pub verification_key: String,
    /// The type of the key.
    pub key_type: VerificationKeyType,
    /// A proof string to be signed by the key's owner to prove initial possession of the private key for this verification key.
    /// This can be any value and is expected to be generated by the front-end for this application for the user to sign.
    pub proof: String,
    /// The signature of the proof string by the private key for this verification key.
    pub proof_signature: Vec<u8>,
    /// Free text name for the key. This is just for human reference, primarily by the key's owner.
    pub name: String,
    /// Expiry, if supported by the key type.
    pub expires_at: Option<DateTime<Utc>>,
}

// TODO validate creation rate?
pub fn validate_create_vf_key_dist(
    create_action: EntryCreationAction,
    vf_key: VerificationKeyDist,
) -> ExternResult<ValidateCallbackResult> {
    if vf_key.name.len() < VERIFICATION_KEY_NAME_MIN_LENGTH {
        return Ok(ValidateCallbackResult::Invalid(format!(
            "Verification key name must be at least {} characters",
            VERIFICATION_KEY_NAME_MIN_LENGTH
        )));
    }

    match vf_key.key_type {
        // Checks that:
        // - The key can be parsed as a MiniSign verification key
        // - The key does not have an expiry
        // - The proof signature is valid
        VerificationKeyType::MiniSignEd25519 => {
            let key = match try_read_mini_sign_vf_key(&vf_key.verification_key) {
                Ok(key) => key,
                Err(e) => {
                    return Ok(ValidateCallbackResult::Invalid(format!(
                        "Failed to read MiniSign verification key: {}",
                        e
                    )));
                }
            };

            if vf_key.expires_at.is_some() {
                return Ok(ValidateCallbackResult::Invalid(String::from(
                    "MiniSign verification keys do not support expiry",
                )));
            }

            if let Err(e) =
                check_mini_sign_proof(&key, vf_key.proof.as_bytes(), vf_key.proof_signature)
            {
                return Ok(ValidateCallbackResult::Invalid(format!(
                    "Failed to verify proof signature: {}",
                    e
                )));
            }
        }
    }

    let activity = {
        // Must check from the previous action otherwise this create action will show up and appear as an
        // existing distribution of the key we're checking isn't already present.
        must_get_agent_activity(
            create_action.author().clone(),
            ChainFilter::new(create_action.prev_action().clone()),
        )?
    };

    let entry_def: AppEntryDef = UnitEntryTypes::VerificationKeyDist.try_into()?;
    let entry_hashes = activity
        .into_iter()
        .filter_map(|activity| match activity.action.action() {
            Action::Create(Create {
                entry_type: EntryType::App(entry_type),
                entry_hash,
                ..
            }) if entry_type == &entry_def => Some(entry_hash.clone()),
            _ => None,
        })
        .collect::<Vec<_>>();

    for entry_hash in entry_hashes {
        let entry: VerificationKeyDist =
            try_extract_entry_to_app_type(must_get_entry(entry_hash)?)?;
        if entry.verification_key == vf_key.verification_key {
            return Ok(ValidateCallbackResult::Invalid(String::from(
                "Verification key already distributed by this agent",
            )));
        }
    }

    Ok(ValidateCallbackResult::Valid)
}

pub fn validate_update_vf_key_dist(
    _action: Update,
    _gpg_key: VerificationKeyDist,
    _original_action: EntryCreationAction,
    _original_gpg_key: VerificationKeyDist,
) -> ExternResult<ValidateCallbackResult> {
    Ok(ValidateCallbackResult::Invalid(String::from(
        "Verification key distributions cannot be updated",
    )))
}

pub fn validate_delete_vf_key_dist(
    _action: Delete,
    _original_action: EntryCreationAction,
    _original_gpg_key: VerificationKeyDist,
) -> ExternResult<ValidateCallbackResult> {
    Ok(ValidateCallbackResult::Invalid(String::from(
        "Verification key distributions cannot be deleted",
    )))
}

/// Validation for links of type [LinkTypes::AgentToVfKeyDist]
pub fn validate_create_agent_to_vf_key_dist_link(
    create_action: CreateLink,
    base_address: AnyLinkableHash,
    target_address: AnyLinkableHash,
    link_type: LinkTypes,
) -> ExternResult<ValidateCallbackResult> {
    // Should never be hit, would imply a mistake in `lib.rs`.
    assert_eq!(
        link_type,
        LinkTypes::AgentToVfKeyDist,
        "Wrong link type: {:?}",
        link_type
    );

    //
    // Check the base
    //
    let base_agent_pub_key: AgentPubKey = match base_address.try_into() {
        Ok(agent_pub_key) => agent_pub_key,
        Err(_) => {
            return Ok(ValidateCallbackResult::Invalid(format!(
                "The base address for {:?} must be an agent public key",
                link_type
            )));
        }
    };

    // Only permit links from 'me'
    if create_action.author != base_agent_pub_key {
        return Ok(ValidateCallbackResult::Invalid(format!(
            "The base address for {:?} must be the author of the link",
            link_type
        )));
    }

    //
    // Check the target
    //
    let entry_hash = match target_address.clone().try_into() {
        Ok(entry_hash) => entry_hash,
        Err(_) => {
            return Ok(ValidateCallbackResult::Invalid(format!(
                "The target address for {:?} must be an entry hash",
                link_type
            )));
        }
    };
    let entry = must_get_entry(entry_hash)?;
    if try_extract_entry_to_app_type::<VerificationKeyDist>(entry).is_err() {
        return Ok(ValidateCallbackResult::Invalid(format!(
            "The target for {:?} must be a {}",
            link_type,
            std::any::type_name::<VerificationKeyDist>()
        )));
    }

    Ok(ValidateCallbackResult::Valid)
}

/// Validation for links of type [LinkTypes::VfKeyDistToAgent]
pub fn validate_create_vf_key_dist_to_agent_link(
    create_action: CreateLink,
    base_address: AnyLinkableHash,
    target_address: AnyLinkableHash,
    link_type: LinkTypes,
) -> ExternResult<ValidateCallbackResult> {
    // Should never be hit, would imply a mistake in `lib.rs`.
    assert_eq!(
        link_type,
        LinkTypes::VfKeyDistToAgent,
        "Wrong link type: {:?}",
        link_type
    );

    //
    // Check the base
    //
    let entry_hash = match base_address.clone().try_into() {
        Ok(entry_hash) => entry_hash,
        Err(_) => {
            return Ok(ValidateCallbackResult::Invalid(format!(
                "The base address for {:?} must be an entry hash",
                link_type
            )));
        }
    };
    let entry = must_get_entry(entry_hash)?;
    if try_extract_entry_to_app_type::<VerificationKeyDist>(entry).is_err() {
        return Ok(ValidateCallbackResult::Invalid(format!(
            "The base for {:?} must be a {}",
            link_type,
            std::any::type_name::<VerificationKeyDist>()
        )));
    }

    //
    // Check the target
    //
    let target_agent_pub_key: AgentPubKey = match target_address.try_into() {
        Ok(agent_pub_key) => agent_pub_key,
        Err(_) => {
            return Ok(ValidateCallbackResult::Invalid(format!(
                "The target address for {:?} must be an agent public key",
                link_type
            )));
        }
    };

    // Only permit links to 'me'
    if create_action.author != target_agent_pub_key {
        return Ok(ValidateCallbackResult::Invalid(format!(
            "The target address for {:?} must be the author of the link",
            link_type
        )));
    }

    Ok(ValidateCallbackResult::Valid)
}
