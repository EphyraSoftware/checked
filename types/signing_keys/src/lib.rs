use checked_types::VerificationKeyType;
use chrono::{DateTime, Utc};
use hdk::prelude::*;

#[hdk_entry_helper]
#[derive(Clone, PartialEq)]
pub struct VerificationKeyDist {
    /// Text representation of the verification key. This will vary by key type.
    pub verification_key: String,
    /// The type of the key.
    pub key_type: VerificationKeyType,
    /// A proof string to be signed by the key's owner to prove initial possession of the private key for this verification key.
    /// This can be any value and is expected to be generated by the front-end for this application for the user to sign.
    pub proof: String,
    /// The signature of the proof string by the private key for this verification key.
    pub proof_signature: Vec<u8>,
    /// Free text name for the key. This is just for human reference, primarily by the key's owner.
    pub name: String,
    /// Expiry, if supported by the key type.
    pub expires_at: Option<DateTime<Utc>>,
}

#[hdk_entry_helper]
pub struct KeyCollection {
    pub name: String,
}

#[derive(Serialize, Deserialize, Debug, Clone, SerializedBytes, PartialEq)]
pub enum MarkVfKeyDistOpt {
    Rotated {
        /// The new verification key distribution address. Useful for agents who have added your key
        /// to a key collection to update to your new key.
        new_verification_key_dist_address: ActionHash,
    },
    Compromised {
        /// Visible to other agents, describe why the key is compromised.
        /// E.g. "Lost the private key", "Private key was accidentally published"
        /// Maximum length of 120 characters.
        note: String,
        /// The date that the key was compromised. This may be used to suppress signatures made with the key after this date.
        since: Timestamp,
    },
}

#[hdk_entry_helper]
#[derive(Clone, PartialEq)]
pub struct VerificationKeyDistMark {
    /// Store the address of the key being marked even though it is also linked, this is for validation purposes.
    pub verification_key_dist_address: ActionHash,
    pub mark: MarkVfKeyDistOpt,
}

/// Reduced form of [VerificationKeyDist] to avoid returning fields that shouldn't be needed by the caller.
#[derive(Serialize, Deserialize, Debug, Clone, SerializedBytes)]
pub struct VerificationKeyDistResponse {
    pub verification_key: String,
    pub key_type: VerificationKeyType,
    pub name: String,
    pub expires_at: Option<DateTime<Utc>>,
    pub marks: Vec<MarkVfKeyDistOpt>,
}

impl From<(VerificationKeyDist, Vec<VerificationKeyDistMark>)> for VerificationKeyDistResponse {
    fn from((vf_key_dist, marks): (VerificationKeyDist, Vec<VerificationKeyDistMark>)) -> Self {
        Self {
            verification_key: vf_key_dist.verification_key,
            key_type: vf_key_dist.key_type,
            name: vf_key_dist.name,
            expires_at: vf_key_dist.expires_at,
            marks: marks.into_iter().map(|m| m.mark).collect(),
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, SerializedBytes)]
pub struct VfKeyResponse {
    pub verification_key_dist: VerificationKeyDistResponse,
    pub key_dist_address: ActionHash,
    pub reference_count: usize,
    pub author: AgentPubKey,
    pub created_at: Timestamp,
}

#[derive(Serialize, Deserialize, Debug, Clone, SerializedBytes)]
pub struct KeyCollectionWithKeys {
    pub name: String,
    pub verification_keys: Vec<VfKeyResponse>,
}
